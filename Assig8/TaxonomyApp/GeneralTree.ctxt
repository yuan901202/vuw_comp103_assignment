#BlueJ class context
comment0.params=
comment0.target=GeneralTree()
comment0.text=\n\ The\ initial\ GeneralTree\ contains\ no\ nodes,\ so\ the\ root\ is\ set\ to\ null\ to\ reflect\ this.\n
comment1.params=target
comment1.target=GeneralTreeNode\ findNode(java.lang.String)
comment1.text=\ \n\ \ Find\ the\ node\ in\ the\ tree\ that\ contains\ the\ given\ string.\n\ \ Traverses\ the\ tree,\ looking\ at\ each\ node.\n\ \ If\ the\ target\ string\ equals\ the\ node's\ string,\ then\ return\ the\ node.\n\ \ If\ no\ node\ is\ found,\ then\ return\ null.\n\ \ Actually\ uses\ a\ private\ helper\ function\ that\ you\ will\ write\ yourselves.\n
comment10.params=depth
comment10.target=void\ listDepth(int)
comment10.text=\ \n\ \ COMPLETION\n\ \ \n\ \ Print\ all\ the\ string\ data\ of\ all\ the\ nodes\ at\ the\ given\ depth.\ Should\ print\ out\ an\ error\ message\ if\ the\ depth\ requested\ is\ <\ 0.\n\ \ Print\ nothing\ if\ the\ depth\ >\=\ 0,\ but\ if\ there\ are\ no\ nodes\ at\ that\ depth.\n\ \n\ \ @param\ depth\ the\ depth\ of\ the\ tree\ whoses\ nodes\ are\ to\ be\ listed.\ The\ root\ is\ at\ depth\ 0.\n
comment11.params=target\ current\ node
comment11.target=void\ listDepth(int,\ int,\ GeneralTreeNode)
comment12.params=target1\ target2
comment12.target=java.lang.String\ findClosestCommonAncestor(java.lang.String,\ java.lang.String)
comment12.text=\ \n\ CHALLENGE\n\ \n\ Given\ two\ nodes\ (identified\ here\ by\ the\ assumed\ unique\ strings\ stored\ in\ those\ nodes),\ return\ the\ string\ at\ a\ third\ node\ that\ \n\ is\ the\ closest\ common\ ancestor\ of\ both\ of\ the\ first\ two\ nodes.\ The\ closest\ common\ ancestor\ is\ the\ node\ that\ is\ the\ root\ of\ the\ \n\ smallest\ subtree\ that\ contains\ both\ the\ first\ two\ nodes.\ The\ closest\ common\ ancestor\ could\ even\ be\ one\ of\ the\ first\ two\ nodes\ identified\ by\ the\ parameters.\ Note\ that\ this\ can\ only\ \n\ return\ null\ if\ one\ of\ the\ targets\ doesn't\ exist,\ as\ the\ tree's\ root\ node\ is\ the\ last\ resort\ as\ a\ common\ ancestor\ to\ all\ nodes\ in\ the\ tree.\n\ \n\ @param\ target1\ \ \ the\ (assumed\ unique)\ string\ in\ the\ first\ node.\n\ @param\ target2\ \ \ the\ (assumed\ unique)\ string\ in\ the\ second\ node.\ \n\ @return\ the\ string\ data\ at\ the\ closest\ common\ ancestor\ node,\ or\ null\ if\ one\ or\ both\ of\ the\ parameter's\ target\ nodes\ don't\ exist.\n
comment13.params=
comment13.target=void\ save()
comment13.text=\n\ \ Save\ the\ whole\ tree\ in\ a\ file\ in\ a\ format\ that\ it\ can\ be\ loaded\ back\ in\n\ \ and\ reconstructed\ \n
comment14.params=node\ ps
comment14.target=void\ saveHelper(GeneralTreeNode,\ java.io.PrintStream)
comment15.params=scan
comment15.target=void\ load(java.util.Scanner)
comment15.text=\n\ \ Construct\ a\ new\ tree\ loaded\ from\ a\ file.\n\ \ \n\ \ @param\ scan\ The\ scanner\ connected\ to\ the\ input\ stream\ of\ the\ file\ to\ be\ loaded\ in\ from.\ \n
comment16.params=data\ scan
comment16.target=GeneralTreeNode\ loadHelper(java.lang.String,\ java.util.Scanner)
comment17.params=
comment17.target=void\ redraw()
comment17.text=\ Redraw\ the\ chart.\n\ \ First\ step\ is\ to\ calculate\ all\ the\ locations\ of\ the\ nodes\ in\ the\ tree.\n\ \ Then\ traverse\ the\ tree\ to\ draw\ all\ the\ nodes\ and\ lines\ between\ parents\ and\ children.\n
comment18.params=node
comment18.target=void\ redrawAllNodes(GeneralTreeNode)
comment18.text=\ \n\ \ CORE\n\ \n\ \ The\ earlier\ redraw()\ method\ handles\ computation\ of\ where\ the\ nodes\ should\ go.\ Now,\ we\ actually\ need\ to\ draw\ each\ node\ at\ the\ location\n\ \ stored\ within\ it,\ and\ then\ draw\ lines\ between\ parents\ and\ children.\n\ \ This\ should\ be\ a\ a\ recursive\ method\ to\ draw\ all\ nodes\ in\ a\ subtree.\ The\ provided\ code\ just\ draws\ the\ tree\ node;\ you\ need\ to\ make\ it\ draw\ all\ the\ nodes\ \n
comment19.params=
comment19.target=void\ calculateLocations()
comment19.text=\ Calculate\ locations\ for\ each\ node\ in\ the\ tree.\n\ \ It\ does\ not\ do\ a\ nice\ job\ -\ it\ just\ lays\ out\ all\ the\ nodes\ on\n\ \ \ each\ level\ evenly\ across\ the\ width\ of\ the\ window.\n\ \ It\ also\ assumes\ that\ the\ depth\ of\ the\ tree\ is\ at\ most\ 100\ \n
comment2.params=target\ node
comment2.target=GeneralTreeNode\ findNode(java.lang.String,\ GeneralTreeNode)
comment2.text=\n\ CORE\n\ \n\ Find\ the\ node\ whose\ data\ is\ equal\ to\ the\ target\ string.\ If\ the\ target\ string\ appears\ multiple\ times,\ then\ just\ return\ the\ \n\ first\ one\ encountered.\ The\ addNode\ method\ should\ guarantee\ that\ duplicate\ strings\ aren't\ added\ however.\n\ \n\ @param\ \ target\ \ the\ (assumed\ unique)\ string,\ that\ is\ in\ the\ node\ we\ want.\ \ \n\ @return\ the\ node\ that\ contains\ the\ target\ string\ (assumed\ to\ be\ unique\ in\ the\ tree),\ or\ null\ if\ no\ such\ node\ exists.\ If\ the\ string\ is\ somehow\ not\n\ unique,\ then\ the\ first\ node\ to\ be\ encountered\ with\ this\ string\ will\ be\ returned.\ It\ cannot\ be\ guaranteed\ that\ this\ is\ the\ same\ node\ each\ time,\ if\n\ duplicates\ exist.\n
comment20.params=node\ depth\ widths
comment20.target=void\ computeWidths(GeneralTreeNode,\ int,\ int[])
comment20.text=\ Compute\ the\ number\ of\ nodes\ at\ each\ level\ of\ the\ tree,\n\ \ by\ accumulating\ the\ count\ in\ the\ widths\ array\ \n
comment21.params=node\ depth\ nextPos\ separations
comment21.target=void\ setLocations(GeneralTreeNode,\ int,\ int[],\ int[])
comment21.text=\ Set\ the\ location\ of\ each\ nodes\ at\ each\ level\ of\ the\ tree,\n\ \ using\ the\ depth\ and\ positions\n
comment22.params=node
comment22.target=void\ redrawNode(GeneralTreeNode)
comment22.text=\n\ Draws\ a\ node\ at\ the\ location\ stored\ in\ that\ node.\ Drawing\ the\ node\ consists\ of\ drawing\ a\ circle,\ and\ writing\ the\ data\ string\n\ out\ "in"\ that\ circle.\ Note\ the\ circle\ doesn't\ really\ know\ the\ length\ of\ the\ string,\ so\ this\ could\ look\ ugly.\n\ \n\ @param\ node\ \ the\ node\ to\ draw\ on\ the\ screen.\ This\ node\ should\ already\ have\ had\ it's\ location\ set\ earlier\ on.\n
comment3.params=data\ parent
comment3.target=void\ addNode(java.lang.String,\ java.lang.String)
comment3.text=\ \n\ \ CORE\ \n\ \ \n\ \ Add\ a\ new\ node\ (with\ the\ data\ string\ stored\ in\ it)\ as\ a\ child\ to\ the\ node\ identified\ with\ the\ parent\ string.\ \n\ \ The\ new\ node\ should\ have\ no\ children.\ There\ is\ one\ exception\ to\ this\ however.\ If\ the\ parent\ string\ is\ null,\ then\n\ \ the\ assumption\ is\ that\ we're\ adding\ a\ new\ root\ node.\ In\ this\ case,\ if\ there\ is\ already\ a\ valid\ root\ node,\ \n\ \ then\ this\ old\ root\ node\ should\ become\ child\ of\ the\ new\ node,\ and\ the\ new\ node\ becomes\ the\ root\ of\ the\ tree.\n\ \ The\ new\ node\ should\ only\ be\ added\ into\ the\ tree\ if\ the\ data\ string\ is\ unique,\ and\ doesn't\ already\ appear\ in\ the\ tree.\n\ \ \n\ \ Do\ nothing\ if\ the\ the\ parent\ string\ is\ not\ null,\ but\ no\ node\ contains\ that\ parent\ string.\ \n
comment4.params=target
comment4.target=void\ removeNode(java.lang.String)
comment4.text=\ \n\ \ CORE\n\ \ \n\ \ This\ method\ removes\ the\ node\ containing\ the\ target\ string\ (usual\ assumptions\ of\ uniqueness\ apply).\ \n\ \ The\ target\ node's\ children\ must\ become\ children\ of\ it's\ parent.\n\ \ Do\ nothing\ if\ the\ node\ is\ the\ root\ node\ of\ the\ entire\ tree\ (or\ if\ target\ node\ doesn't\ exist).\ \n
comment5.params=target\ destination
comment5.target=void\ moveNode(java.lang.String,\ java.lang.String)
comment5.text=\ \n\ \ COMPLETION\n\ \n\ \ Move\ the\ target\ node\ to\ be\ a\ child\ of\ the\ destination\ node,\ along\ with\n\ \ the\ subtree\ under\ node.\n\ \ Note\ that\ this\ is\ a\ problem\ if\ the\ "to"\ node\ is\ in\ the\ subtree\n\ \ treeed\ at\ node\ (including\ if\ the\ "to"\ node\ is\ the\ same\ as\ node)\n\ \ Testing\ for\ this\ situation\ is\ an\ extension.\ \n
comment6.params=node\ subtree
comment6.target=boolean\ inSubtree(GeneralTreeNode,\ GeneralTreeNode)
comment6.text=\ \n\ \ COMPLETION\n\ \n\ \ This\ method\ returns\ true\ or\ false\ depending\ on\ whether\ the\ node\ in\ the\ first\ parameter\ is\ actually\ in\ the\ subtree\ whose\ root\ \n\ \ is\ the\ node\ in\ the\ second\ parameter.\ This\ method\ is\ used\ by\ moveNode(...),\ to\ ensure\ that\ we\ aren't\ trying\ to\ move\ a\ node\ \n\ \ (and\ hence\ the\ subtree\ rooted\ at\ that\ node)\ in\ a\ way\ that\ makes\ it\ become\ a\ child\ of\ one\ of\ it's\ existing\ descendants.\ \n\ \ \n\ \ @return\ true\ if\ the\ node\ is\ in\ the\ subtree,\ and\ false\ otherwise\n\ \ \n
comment7.params=target
comment7.target=void\ listSubtree(java.lang.String)
comment7.text=\ \n\ \ CORE\n\ \ \n\ \ Print\ the\ strings\ of\ all\ the\ nodes\ under\ the\ given\ target\ node\ \n\ \ (including\ the\ target\ node\ itself).\n\ \ \n\ \ @param\ target\ the\ assumed\ unique\ string\ that\ identifies\ the\ desired\ node.\ As\ elsewhere,\ if\ the\ \n\ \ condition\ that\ strings\ are\ unique\ in\ the\ tree\ is\ broken,\ then\ it\ is\ acceptable\ to\ print\ out\ the\ strings\ \n\ \ in\ the\ first\ matching\ subtree\ found.\n\ \ \n
comment8.params=node
comment8.target=void\ listSubtree(GeneralTreeNode)
comment9.params=target
comment9.target=void\ listChain(java.lang.String)
comment9.text=\ \n\ \ COMPLETION\n\ \n\ \ List\ the\ names\ of\ all\ the\ nodes\ in\ the\ chain/path\ from\ this\ node\ to\ the\ root\ of\ the\ entire\ tree.\ You\ may\ report\ them\ in\ \n\ \ either\ top-down\ or\ bottom-up\ order.\n
numComments=23
